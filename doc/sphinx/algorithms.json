[
  {
    "function": {
      "name": "gds.allShortestPaths.delta.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Delta Stepping shortest path algorithm computes the shortest (weighted) path\nbetween one node and any other node in the graph. The computation is run multi-threaded.\n\n"
  },
  {
    "function": {
      "name": "gds.allShortestPaths.delta.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for allShortestPaths.dealta.mutate.\n\n"
  },
  {
    "function": {
      "name": "gds.allShortestPaths.delta.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Delta Stepping shortest path algorithm computes the shortest (weighted) path\nbetween one node and any other node in the graph. The computation is run multi-threaded\n\n"
  },
  {
    "function": {
      "name": "gds.allShortestPaths.delta.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for allShortestPaths.delta.stats.\n\n"
  },
  {
    "function": {
      "name": "gds.allShortestPaths.delta.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Delta Stepping shortest path algorithm computes the shortest (weighted) path\nbetween one node and any other node in the graph. The computation is run multi-threaded.\n\n"
  },
  {
    "function": {
      "name": "gds.allShortestPaths.delta.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for allShortestPaths.delta.strema.\n\n"
  },
  {
    "function": {
      "name": "gds.allShortestPaths.delta.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Delta Stepping shortest path algorithm computes the shortest (weighted) path\nbetween one node and any other node in the graph. The computation is run multi-threaded.\n\n"
  },
  {
    "function": {
      "name": "gds.allShortestPaths.delta.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.allShortestPaths.dijkstra.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Dijkstra shortest path algorithm computes the shortest (weighted) path\nbetween one node and any other node in the graph.\n\n"
  },
  {
    "function": {
      "name": "gds.allShortestPaths.dijkstra.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.allShortestPaths.dijkstra.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Dijkstra shortest path algorithm computes the shortest (weighted) path\nbetween one node and any other node in the graph.\n\n"
  },
  {
    "function": {
      "name": "gds.allShortestPaths.dijkstra.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.allShortestPaths.dijkstra.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Dijkstra shortest path algorithm computes the shortest (weighted) path\nbetween one node and any other node in the graph.\n\n"
  },
  {
    "function": {
      "name": "gds.allShortestPaths.dijkstra.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.allShortestPaths.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe All Pairs Shortest Path (APSP) calculates the shortest (weighted) path\nbetween all pairs of nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.allShortestPaths.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe All Pairs Shortest Path (APSP) calculates the shortest (weighted) path\nbetween all pairs of nodes.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.allShortestPaths.stream` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.closeness.harmonic.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nHarmonic centrality is a way of detecting nodes that are able to spread information\nvery efficiently through a graph.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.closeness.harmonic.stream` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.closeness.harmonic.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nHarmonic centrality is a way of detecting nodes that are able to spread information\nvery efficiently through a graph.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.closeness.harmonic.write` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.conductance.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nEvaluates a division of nodes into communities based on the proportion of relationships\nthat cross community boundaries.\n\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.graph.sample.rwr",
      "signature": "graph_name: str, from_G: Graph, **config: Any",
      "return_type": "GraphCreateResult"
    },
    "description": "\nConstructs a random subgraph based on random walks with restarts.\n\n",
    "deprecated": {
      "version": "2.4.0",
      "message": "Since GDS server version 2.4.0 you should use the endpoint :func:`gds.graph.sample.rwr` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.hits.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nHyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.hits.mutate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.hits.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.hits.mutate.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.hits.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nHyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.hits.stats` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.hits.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.hits.stats.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.hits.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nHyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.hits.stream` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.hits.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.hits.stream.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.hits.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nHyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.hits.write` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.hits.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.hits.write.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.kSpanningTree.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe K-spanning tree algorithm starts from a root node and returns a spanning tree with exactly k nodes\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kSpanningTree.write` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.knn.filtered.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties.\nFiltered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.knn.filtered.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties.\nFiltered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.knn.filtered.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties.\nFiltered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.knn.filtered.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties.\nFiltered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.maxkcut.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nApproximate Maximum k-cut maps each node into one of k disjoint communities\ntrying to maximize the sum of weights of relationships between these communities.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.maxkcut.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nApproximate Maximum k-cut maps each node into one of k disjoint communities\ntrying to maximize the sum of weights of relationships between these communities.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.maxkcut.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nApproximate Maximum k-cut maps each node into one of k disjoint communities\ntrying to maximize the sum of weights of relationships between these communities.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.maxkcut.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nApproximate Maximum k-cut maps each node into one of k disjoint communities\ntrying to maximize the sum of weights of relationships between these communities.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.modularity.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\n"
  },
  {
    "function": {
      "name": "gds.alpha.modularity.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\n"
  },
  {
    "function": {
      "name": "gds.alpha.nodeSimilarity.filtered.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nThe algorithm computes pair-wise similarities based on Jaccard or Overlap metrics.\nThe filtered variant supports limiting which nodes to compare via source and target node filters.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.nodeSimilarity.filtered.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.nodeSimilarity.filtered.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nThe algorithm computes pair-wise similarities based on Jaccard or Overlap metrics.\nThe filtered variant supports limiting which nodes to compare via source and target node filters.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.nodeSimilarity.filtered.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.nodeSimilarity.filtered.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nThe algorithm computes pair-wise similarities based on Jaccard or Overlap metrics.\nThe filtered variant supports limiting which nodes to compare via source and target node filters.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.nodeSimilarity.filtered.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.nodeSimilarity.filtered.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nThe algorithm computes pair-wise similarities based on Jaccard or Overlap metrics.\nThe filtered variant supports limiting which nodes to compare via source and target node filters.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.nodeSimilarity.filtered.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.scaleProperties.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nScale node properties\n\n",
    "deprecated": {
      "version": "2.4.0",
      "message": "Since GDS server version 2.4.0 you should use the endpoint :func:`gds.scaleProperties.mutate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.scaleProperties.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nScale node properties\n\n",
    "deprecated": {
      "version": "2.4.0",
      "message": "Since GDS server version 2.4.0 you should use the endpoint :func:`gds.scaleProperties.stream` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.scc.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe SCC algorithm finds sets of connected nodes in an directed graph,\nwhere all nodes in the same set form a connected component.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.scc.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe SCC algorithm finds sets of connected nodes in an directed graph,\nwhere all nodes in the same set form a connected component.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.sllpa.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.sllpa.mutate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.sllpa.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.sllpa.mutate.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.sllpa.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.sllpa.stats` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.sllpa.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.sllpa.stats.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.sllpa.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.sllpa.stream` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.sllpa.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.sllpa.stream.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.sllpa.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.sllpa.write` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.sllpa.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.sllpa.write.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.alpha.triangles",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nTriangles streams the nodeIds of each triangle in the graph.\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.triangles` instead."
    }
  },
  {
    "function": {
      "name": "gds.articleRank.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nArticle Rank is a variant of the Page Rank algorithm, which measures the transitive influence or connectivity of nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.articleRank.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.articleRank.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nExecutes the algorithm and returns result statistics without writing the result to Neo4j.\n\n"
  },
  {
    "function": {
      "name": "gds.articleRank.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.articleRank.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nArticle Rank is a variant of the Page Rank algorithm, which measures the transitive influence or connectivity of nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.articleRank.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.articleRank.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nArticle Rank is a variant of the Page Rank algorithm, which measures the transitive influence or connectivity of nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.articleRank.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.bellmanFord.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Bellman-Ford shortest path algorithm computes the shortest (weighted) path between one node\nand any other node in the graph without negative cycles.\n\n"
  },
  {
    "function": {
      "name": "gds.bellmanFord.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.bellmanFord.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Bellman-Ford shortest path algorithm computes the shortest (weighted) path between one node\nand any other node in the graph without negative cycles.\n\n"
  },
  {
    "function": {
      "name": "gds.bellmanFord.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.bellmanFord.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Bellman-Ford shortest path algorithm computes the shortest (weighted) path between one node\nand any other node in the graph without negative cycles.\n\n"
  },
  {
    "function": {
      "name": "gds.bellmanFord.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.bellmanFord.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Bellman-Ford shortest path algorithm computes the shortest (weighted) path between one node\nand any other node in the graph without negative cycles.\n\n"
  },
  {
    "function": {
      "name": "gds.bellmanFord.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.closeness.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nCloseness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.closeness.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nCloseness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.closeness.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nCloseness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.closeness.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nCloseness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.collapsePath.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nCollapse Path algorithm is a traversal algorithm capable of creating relationships between the start\nand end nodes of a traversal\n\n"
  },
  {
    "function": {
      "name": "gds.beta.influenceMaximization.celf.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes\nthat maximize the expected spread of influence in the network.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.influenceMaximization.celf.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.influenceMaximization.celf.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nExecutes the algorithm and returns result statistics without writing the result to Neo4j.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.influenceMaximization.celf.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.influenceMaximization.celf.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes\nthat maximize the expected spread of influence in the network.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.influenceMaximization.celf.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes\nthat maximize the expected spread of influence in the network.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.influenceMaximization.celf.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes\nthat maximize the expected spread of influence in the network.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.influenceMaximization.celf.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.k1coloring.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe K-1 Coloring algorithm assigns a color to every node in the graph.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.k1coloring.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.k1coloring.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe K-1 Coloring algorithm assigns a color to every node in the graph.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.k1coloring.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.k1coloring.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe K-1 Coloring algorithm assigns a color to every node in the graph.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.k1coloring.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.k1coloring.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe K-1 Coloring algorithm assigns a color to every node in the graph.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.k1coloring.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.kmeans.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Kmeans  algorithm clusters nodes into different communities based on Euclidean distance\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kmeans.mutate` instead."
    }
  },
  {
    "function": {
      "name": "gds.beta.kmeans.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kmeans.mutate.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.beta.kmeans.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Kmeans  algorithm clusters nodes into different communities based on Euclidean distance\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kmeans.stats` instead."
    }
  },
  {
    "function": {
      "name": "gds.beta.kmeans.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kmeans.stats.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.beta.kmeans.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Kmeans  algorithm clusters nodes into different communities based on Euclidean distance\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kmeans.stream` instead."
    }
  },
  {
    "function": {
      "name": "gds.beta.kmeans.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kmeans.stream.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.beta.kmeans.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Kmeans  algorithm clusters nodes into different communities based on Euclidean distance\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kmeans.write` instead."
    }
  },
  {
    "function": {
      "name": "gds.beta.kmeans.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n",
    "deprecated": {
      "version": "2.5.0",
      "message": "Since GDS server version 2.5.0 you should use the endpoint :func:`gds.kmeans.write.estimate` instead."
    }
  },
  {
    "function": {
      "name": "gds.beta.leiden.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nLeiden is a community detection algorithm, which guarantees that communities are well connected\n\n"
  },
  {
    "function": {
      "name": "gds.beta.leiden.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.leiden.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nExecutes the algorithm and returns result statistics without writing the result to Neo4j.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.leiden.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.leiden.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nLeiden is a community detection algorithm, which guarantees that communities are well connected\n\n"
  },
  {
    "function": {
      "name": "gds.beta.leiden.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.leiden.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nLeiden is a community detection algorithm, which guarantees that communities are well connected\n\n"
  },
  {
    "function": {
      "name": "gds.beta.leiden.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.modularityOptimization.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.modularityOptimization.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.modularityOptimization.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.modularityOptimization.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.modularityOptimization.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.modularityOptimization.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.scaleProperties.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nScale node properties\n\n"
  },
  {
    "function": {
      "name": "gds.scaleProperties.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.scaleProperties.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nScale node properties\n\n"
  },
  {
    "function": {
      "name": "gds.scaleProperties.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.scaleProperties.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nScale node properties\n\n"
  },
  {
    "function": {
      "name": "gds.scaleProperties.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.scaleProperties.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nScale node properties\n\n"
  },
  {
    "function": {
      "name": "gds.scaleProperties.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.scc.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component.\n\n"
  },
  {
    "function": {
      "name": "gds.scc.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for SCC.\n\n"
  },
  {
    "function": {
      "name": "gds.scc.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component.\n\n"
  },
  {
    "function": {
      "name": "gds.scc.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for SCC.\n\n"
  },
  {
    "function": {
      "name": "gds.scc.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component.\n\n"
  },
  {
    "function": {
      "name": "gds.scc.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for SCC.\n\n"
  },
  {
    "function": {
      "name": "gds.scc.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component.\n\n"
  },
  {
    "function": {
      "name": "gds.scc.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for SCC.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.spanningTree.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe spanning tree algorithm visits all nodes that are in the same connected component as the starting node,\nand returns a spanning tree of all nodes in the component where the total weight of the relationships is either minimized or maximized.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.spanningTree.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.spanningTree.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe spanning tree algorithm visits all nodes that are in the same connected component as the starting node,\nand returns a spanning tree of all nodes in the component\nwhere the total weight of the relationships is either minimized or maximized.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.spanningTree.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.spanningTree.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe spanning tree algorithm visits all nodes that are in the same connected component as the starting node,\nand returns a spanning tree of all nodes in the component\nwhere the total weight of the relationships is either minimized or maximized.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.spanningTree.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.spanningTree.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe spanning tree algorithm visits all nodes that are in the same connected component as the starting node,\nand returns a spanning tree of all nodes in the component\nwhere the total weight of the relationships is either minimized or maximized.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.spanningTree.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.steinerTree.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe steiner tree algorithm accepts a source node, as well as a list of target nodes.\nIt then attempts to find a spanning tree where there is a path from the source node to each target node,\nsuch that the total weight of the relationships is as low as possible.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.steinerTree.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe steiner tree algorithm accepts a source node, as well as a list of target nodes.\nIt then attempts to find a spanning tree where there is a path from the source node to each target node,\nsuch that the total weight of the relationships is as low as possible.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.steinerTree.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe steiner tree algorithm accepts a source node, as well as a list of target nodes.\nIt then attempts to find a spanning tree where there is a path from the source node to each target node,\nsuch that the total weight of the relationships is as low as possible.\n\n"
  },
  {
    "function": {
      "name": "gds.beta.steinerTree.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe steiner tree algorithm accepts a source node, as well as a list of target nodes.\nIt then attempts to find a spanning tree where there is a path from the source node to each target node,\nsuch that the total weight of the relationships is as low as possible.\n\n"
  },
  {
    "function": {
      "name": "gds.betweenness.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nBetweenness centrality measures the relative information flow that passes through a node.\n\n"
  },
  {
    "function": {
      "name": "gds.betweenness.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nBetweenness centrality measures the relative information flow that passes through a node.\n\n"
  },
  {
    "function": {
      "name": "gds.betweenness.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nBetweenness centrality measures the relative information flow that passes through a node.\n\n"
  },
  {
    "function": {
      "name": "gds.betweenness.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nBetweenness centrality measures the relative information flow that passes through a node.\n\n"
  },
  {
    "function": {
      "name": "gds.betweenness.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nBetweenness centrality measures the relative information flow that passes through a node.\n\n"
  },
  {
    "function": {
      "name": "gds.betweenness.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nBetweenness centrality measures the relative information flow that passes through a node.\n\n"
  },
  {
    "function": {
      "name": "gds.betweenness.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nBetweenness centrality measures the relative information flow that passes through a node.\n\n"
  },
  {
    "function": {
      "name": "gds.betweenness.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nBetweenness centrality measures the relative information flow that passes through a node.\n\n"
  },
  {
    "function": {
      "name": "gds.bfs.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nBFS is a traversal algorithm, which explores all of the neighbor nodes at the present depth\nprior to moving on to the nodes at the next depth level.\n\n"
  },
  {
    "function": {
      "name": "gds.bfs.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.bfs.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nBFS is a traversal algorithm, which explores all of the neighbor nodes at the present depth\nprior to moving on to the nodes at the next depth level.\n\n"
  },
  {
    "function": {
      "name": "gds.bfs.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.bfs.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nBFS is a traversal algorithm, which explores all of the neighbor nodes at the present depth\nprior to moving on to the nodes at the next depth level.\n\n"
  },
  {
    "function": {
      "name": "gds.bfs.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nBFS is a traversal algorithm, which explores all of the neighbor nodes at the present depth\nprior to moving on to the nodes at the next depth level.\"\"\"\n\n"
  },
  {
    "function": {
      "name": "gds.closeness.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nCloseness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.closeness.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nCloseness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.closeness.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nCloseness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.closeness.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nCloseness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.closeness.harmonic.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nHarmonic centrality is a way of detecting nodes that are able to spread information\nvery efficiently through a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.closeness.harmonic.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nHarmonic centrality is a way of detecting nodes that are able to spread information\nvery efficiently through a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.closeness.harmonic.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nHarmonic centrality is a way of detecting nodes that are able to spread information\nvery efficiently through a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.closeness.harmonic.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nHarmonic centrality is a way of detecting nodes that are able to spread information\nvery efficiently through a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.collapsePath.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nCollapse Path algorithm is a traversal algorithm capable of creating relationships between the start\nand end nodes of a traversal\n\n"
  },
  {
    "function": {
      "name": "gds.conductance.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nEvaluates a division of nodes into communities based on the proportion of relationships\nthat cross community boundaries.\n\n"
  },
  {
    "function": {
      "name": "gds.dag.topologicalSort.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nReturns a topological ordering of the nodes in a directed acyclic graph (DAG).\n\n"
  },
  {
    "function": {
      "name": "gds.dag.longestPath.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nFinds the longest path that leads to a node in a directed acyclic graph (DAG).\n\n"
  },
  {
    "function": {
      "name": "gds.degree.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nDegree centrality measures the number of incoming and outgoing relationships from a node.\n\n"
  },
  {
    "function": {
      "name": "gds.degree.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nDegree centrality measures the number of incoming and outgoing relationships from a node.\n\n"
  },
  {
    "function": {
      "name": "gds.degree.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nDegree centrality measures the number of incoming and outgoing relationships from a node.\n\n"
  },
  {
    "function": {
      "name": "gds.degree.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nDegree centrality measures the number of incoming and outgoing relationships from a node.\n\n"
  },
  {
    "function": {
      "name": "gds.degree.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nDegree centrality measures the number of incoming and outgoing relationships from a node.\n\n"
  },
  {
    "function": {
      "name": "gds.degree.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nDegree centrality measures the number of incoming and outgoing relationships from a node.\n\n"
  },
  {
    "function": {
      "name": "gds.degree.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nDegree centrality measures the number of incoming and outgoing relationships from a node.\n\n"
  },
  {
    "function": {
      "name": "gds.degree.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nDegree centrality measures the number of incoming and outgoing relationships from a node.\n\n"
  },
  {
    "function": {
      "name": "gds.dfs.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nDepth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures.\nThe algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph)\nand explores as far as possible along each branch before backtracking.\n\n"
  },
  {
    "function": {
      "name": "gds.dfs.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.dfs.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nDepth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures.\nThe algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph)\nand explores as far as possible along each branch before backtracking.\n\n"
  },
  {
    "function": {
      "name": "gds.dfs.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nDepth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures.\nThe algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph)\nand explores as far as possible along each branch before backtracking.\n\n"
  },
  {
    "function": {
      "name": "gds.eigenvector.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nEigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.eigenvector.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.eigenvector.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nEigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.eigenvector.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.eigenvector.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nEigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.eigenvector.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.eigenvector.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nEigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.eigenvector.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.graph.sample.cnarw",
      "signature": "graph_name: str, from_G: Graph, **config: Any",
      "return_type": "GraphCreateResult"
    },
    "description": "\nConstructs a random subgraph based on common-neighbour-aware random walks.\n\n"
  },
  {
    "function": {
      "name": "gds.graph.sample.cnarw.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.graph.sample.rwr",
      "signature": "graph_name: str, from_G: Graph, **config: Any",
      "return_type": "GraphCreateResult"
    },
    "description": "\nConstructs a random subgraph based on random walks with restarts.\n\n"
  },
  {
    "function": {
      "name": "gds.hits.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nHyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.hits.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.hits.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nHyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.hits.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.hits.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nHyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.hits.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.hits.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nHyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.hits.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.influenceMaximization.celf.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes\nthat maximize the expected spread of influence in the network.\n\n"
  },
  {
    "function": {
      "name": "gds.influenceMaximization.celf.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.influenceMaximization.celf.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nExecutes the algorithm and returns result statistics without writing the result to Neo4j.\n\n"
  },
  {
    "function": {
      "name": "gds.influenceMaximization.celf.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.influenceMaximization.celf.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes\nthat maximize the expected spread of influence in the network.\n\n"
  },
  {
    "function": {
      "name": "gds.influenceMaximization.celf.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes\nthat maximize the expected spread of influence in the network.\n\n"
  },
  {
    "function": {
      "name": "gds.influenceMaximization.celf.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes\nthat maximize the expected spread of influence in the network.\n\n"
  },
  {
    "function": {
      "name": "gds.influenceMaximization.celf.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.kmeans.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Kmeans  algorithm clusters nodes into different communities based on Euclidean distance\n\n"
  },
  {
    "function": {
      "name": "gds.kmeans.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.kmeans.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Kmeans  algorithm clusters nodes into different communities based on Euclidean distance\n\n"
  },
  {
    "function": {
      "name": "gds.kmeans.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.kmeans.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Kmeans  algorithm clusters nodes into different communities based on Euclidean distance\n\n"
  },
  {
    "function": {
      "name": "gds.kmeans.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.kmeans.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Kmeans  algorithm clusters nodes into different communities based on Euclidean distance\n\n"
  },
  {
    "function": {
      "name": "gds.kmeans.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n"
  },
  {
    "function": {
      "name": "gds.k1coloring.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe K-1 Coloring algorithm assigns a color to every node in the graph.\n\n"
  },
  {
    "function": {
      "name": "gds.k1coloring.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.k1coloring.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe K-1 Coloring algorithm assigns a color to every node in the graph.\n\n"
  },
  {
    "function": {
      "name": "gds.k1coloring.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.k1coloring.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe K-1 Coloring algorithm assigns a color to every node in the graph.\n\n"
  },
  {
    "function": {
      "name": "gds.k1coloring.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.k1coloring.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe K-1 Coloring algorithm assigns a color to every node in the graph.\n\n"
  },
  {
    "function": {
      "name": "gds.k1coloring.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.kcore.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nComputes the k-core values in a network\n\n"
  },
  {
    "function": {
      "name": "gds.kcore.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.kcore.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nComputes the k-core values in a network\n\n"
  },
  {
    "function": {
      "name": "gds.kcore.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.kcore.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nComputes the k-core values in a network\n\n"
  },
  {
    "function": {
      "name": "gds.kcore.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.kcore.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nComputes the k-core values in a network\n\n"
  },
  {
    "function": {
      "name": "gds.kcore.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.knn.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties\n\n"
  },
  {
    "function": {
      "name": "gds.knn.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.knn.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties\n\n"
  },
  {
    "function": {
      "name": "gds.knn.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.knn.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties\n\n"
  },
  {
    "function": {
      "name": "gds.knn.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.knn.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties\n\n"
  },
  {
    "function": {
      "name": "gds.knn.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.knn.filtered.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties.\nFiltered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively.\n\n.. py:function:: gds.knn.filtered.mutate.estimate(G: Graph, **config: Any) -> Series[Any]\n\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.knn.filtered.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties.\nFiltered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively.\n\n"
  },
  {
    "function": {
      "name": "gds.knn.filtered.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.knn.filtered.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties.\nFiltered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively.\n\n"
  },
  {
    "function": {
      "name": "gds.knn.filtered.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.knn.filtered.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe k-nearest neighbor graph algorithm constructs relationships between nodes if the distance\nbetween two nodes is among the k nearest distances compared to other nodes.\nKNN computes distances based on the similarity of node properties.\nFiltered KNN extends this functionality, allowing filtering on source nodes and target nodes, respectively.\n\n"
  },
  {
    "function": {
      "name": "gds.knn.filtered.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.kSpanningTree.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe K-spanning tree algorithm starts from a root node and returns a spanning tree with exactly k nodes\n\n"
  },
  {
    "function": {
      "name": "gds.labelPropagation.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Label Propagation algorithm is a fast algorithm for finding communities in a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.labelPropagation.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.labelPropagation.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Label Propagation algorithm is a fast algorithm for finding communities in a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.labelPropagation.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.labelPropagation.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Label Propagation algorithm is a fast algorithm for finding communities in a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.labelPropagation.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.labelPropagation.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Label Propagation algorithm is a fast algorithm for finding communities in a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.labelPropagation.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.leiden.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nLeiden is a community detection algorithm, which guarantees that communities are well connected\n\n"
  },
  {
    "function": {
      "name": "gds.leiden.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.leiden.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nExecutes the algorithm and returns result statistics without writing the result to Neo4j.\n\n"
  },
  {
    "function": {
      "name": "gds.leiden.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.leiden.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nLeiden is a community detection algorithm, which guarantees that communities are well connected\n\n"
  },
  {
    "function": {
      "name": "gds.leiden.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.leiden.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nLeiden is a community detection algorithm, which guarantees that communities are well connected\n\n"
  },
  {
    "function": {
      "name": "gds.leiden.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n\n"
  },
  {
    "function": {
      "name": "gds.localClusteringCoefficient.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe local clustering coefficient is a metric quantifying how connected the neighborhood of a node is.\n\n"
  },
  {
    "function": {
      "name": "gds.localClusteringCoefficient.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.localClusteringCoefficient.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nExecutes the algorithm and returns result statistics without writing the result to Neo4j.\n\n"
  },
  {
    "function": {
      "name": "gds.localClusteringCoefficient.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.localClusteringCoefficient.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe local clustering coefficient is a metric quantifying how connected the neighborhood of a node is.\n\n"
  },
  {
    "function": {
      "name": "gds.localClusteringCoefficient.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.localClusteringCoefficient.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe local clustering coefficient is a metric quantifying how connected the neighborhood of a node is.\n\n"
  },
  {
    "function": {
      "name": "gds.localClusteringCoefficient.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.louvain.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Louvain method for community detection is an algorithm for detecting communities in networks.\n\n"
  },
  {
    "function": {
      "name": "gds.louvain.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.louvain.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nExecutes the algorithm and returns result statistics without writing the result to Neo4j.\n\n"
  },
  {
    "function": {
      "name": "gds.louvain.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.louvain.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Louvain method for community detection is an algorithm for detecting communities in networks.\n\n"
  },
  {
    "function": {
      "name": "gds.louvain.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.louvain.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Louvain method for community detection is an algorithm for detecting communities in networks.\n\n"
  },
  {
    "function": {
      "name": "gds.louvain.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.maxkcut.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nApproximate Maximum k-cut maps each node into one of k disjoint communities\ntrying to maximize the sum of weights of relationships between these communities.\n\n"
  },
  {
    "function": {
      "name": "gds.maxkcut.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nApproximate Maximum k-cut maps each node into one of k disjoint communities\ntrying to maximize the sum of weights of relationships between these communities.\n\n"
  },
  {
    "function": {
      "name": "gds.maxkcut.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nApproximate Maximum k-cut maps each node into one of k disjoint communities\ntrying to maximize the sum of weights of relationships between these communities.\n\n"
  },
  {
    "function": {
      "name": "gds.maxkcut.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nApproximate Maximum k-cut maps each node into one of k disjoint communities\ntrying to maximize the sum of weights of relationships between these communities.\n\n"
  },
  {
    "function": {
      "name": "gds.modularity.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\n"
  },
  {
    "function": {
      "name": "gds.modularity.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\n"
  },
  {
    "function": {
      "name": "gds.modularity.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\n"
  },
  {
    "function": {
      "name": "gds.modularity.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\n"
  },
  {
    "function": {
      "name": "gds.modularityOptimization.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity.\n\n"
  },
  {
    "function": {
      "name": "gds.modularityOptimization.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.modularityOptimization.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity.\n\n"
  },
  {
    "function": {
      "name": "gds.modularityOptimization.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.modularityOptimization.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity.\n\n"
  },
  {
    "function": {
      "name": "gds.modularityOptimization.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.modularityOptimization.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity.\n\n"
  },
  {
    "function": {
      "name": "gds.modularityOptimization.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n\n"
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nNode Similarity computes pair-wise similarities based on the Jaccard metric.\n\n"
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nNode Similarity computes pair-wise similarities based on the Jaccard metric.\n\n"
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nNode Similarity computes pair-wise similarities based on the Jaccard metric.\n\n"
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nNode Similarity computes pair-wise similarities based on the Jaccard metric.\n\n"
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.filtered.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nThe algorithm computes pair-wise similarities based on Jaccard or Overlap metrics.\nThe filtered variant supports limiting which nodes to compare via source and target node filters.\n\n"
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.filtered.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.filtered.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nThe algorithm computes pair-wise similarities based on Jaccard or Overlap metrics.\nThe filtered variant supports limiting which nodes to compare via source and target node filters.\n\n"
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.filtered.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.filtered.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nThe algorithm computes pair-wise similarities based on Jaccard or Overlap metrics.\nThe filtered variant supports limiting which nodes to compare via source and target node filters.\n\n"
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.filtered.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.filtered.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Filtered Node Similarity algorithm compares a set of nodes based on the nodes they are connected to.\nTwo nodes are considered similar if they share many of the same neighbors.\nThe algorithm computes pair-wise similarities based on Jaccard or Overlap metrics.\nThe filtered variant supports limiting which nodes to compare via source and target node filters.\n\n"
  },
  {
    "function": {
      "name": "gds.nodeSimilarity.filtered.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.pageRank.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nPage Rank is an algorithm that measures the transitive influence or connectivity of nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.pageRank.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.pageRank.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nExecutes the algorithm and returns result statistics without writing the result to Neo4j.\n\n"
  },
  {
    "function": {
      "name": "gds.pageRank.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.pageRank.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nPage Rank is an algorithm that measures the transitive influence or connectivity of nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.pageRank.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.pageRank.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nPage Rank is an algorithm that measures the transitive influence or connectivity of nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.pageRank.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.randomWalk.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nRandom Walk is an algorithm that provides random paths in a graph. It\u2019s similar to how a drunk person traverses a city.\n\n"
  },
  {
    "function": {
      "name": "gds.randomWalk.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.randomWalk.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nRandom Walk is an algorithm that provides random paths in a graph. It\u2019s similar to how a drunk person traverses a city.\n\n"
  },
  {
    "function": {
      "name": "gds.randomWalk.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.astar.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight\nproperty to compare path lengths. In addition,\nthis implementation uses the haversine distance as a heuristic to converge faster.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.astar.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.astar.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight\nproperty to compare path lengths. In addition,\nthis implementation uses the haversine distance as a heuristic to converge faster.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.astar.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.astar.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight\nproperty to compare path lengths. In addition,\nthis implementation uses the haversine distance as a heuristic to converge faster.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.astar.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.dijkstra.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.dijkstra.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.dijkstra.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.dijkstra.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.dijkstra.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.dijkstra.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.yens.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.yens.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.yens.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.yens.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.yens.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes.\n\n"
  },
  {
    "function": {
      "name": "gds.shortestPath.yens.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.sllpa.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.sllpa.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.sllpa.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.sllpa.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.sllpa.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.sllpa.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.sllpa.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.\n\n"
  },
  {
    "function": {
      "name": "gds.sllpa.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.spanningTree.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe spanning tree algorithm visits all nodes that are in the same connected component as the starting node,\nand returns a spanning tree of all nodes in the component where the total weight of the relationships is either minimized or maximized.\n\n"
  },
  {
    "function": {
      "name": "gds.spanningTree.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.spanningTree.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe spanning tree algorithm visits all nodes that are in the same connected component as the starting node,\nand returns a spanning tree of all nodes in the component\nwhere the total weight of the relationships is either minimized or maximized.\n\n"
  },
  {
    "function": {
      "name": "gds.spanningTree.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.spanningTree.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe spanning tree algorithm visits all nodes that are in the same connected component as the starting node,\nand returns a spanning tree of all nodes in the component\nwhere the total weight of the relationships is either minimized or maximized.\n\n"
  },
  {
    "function": {
      "name": "gds.spanningTree.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.spanningTree.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe spanning tree algorithm visits all nodes that are in the same connected component as the starting node,\nand returns a spanning tree of all nodes in the component\nwhere the total weight of the relationships is either minimized or maximized.\n\n"
  },
  {
    "function": {
      "name": "gds.spanningTree.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.steinerTree.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe steiner tree algorithm accepts a source node, as well as a list of target nodes.\nIt then attempts to find a spanning tree where there is a path from the source node to each target node,\nsuch that the total weight of the relationships is as low as possible.\n\n"
  },
  {
    "function": {
      "name": "gds.steinerTree.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.steinerTree.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe steiner tree algorithm accepts a source node, as well as a list of target nodes.\nIt then attempts to find a spanning tree where there is a path from the source node to each target node,\nsuch that the total weight of the relationships is as low as possible.\n\n"
  },
  {
    "function": {
      "name": "gds.steinerTree.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.steinerTree.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe steiner tree algorithm accepts a source node, as well as a list of target nodes.\nIt then attempts to find a spanning tree where there is a path from the source node to each target node,\nsuch that the total weight of the relationships is as low as possible.\n\n"
  },
  {
    "function": {
      "name": "gds.steinerTree.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.steinerTree.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe steiner tree algorithm accepts a source node, as well as a list of target nodes.\nIt then attempts to find a spanning tree where there is a path from the source node to each target node,\nsuch that the total weight of the relationships is as low as possible.\n\n"
  },
  {
    "function": {
      "name": "gds.steinerTree.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.triangleCount.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nTriangle counting is a community detection graph algorithm that is used to\ndetermine the number of triangles passing through each node in the graph.\n\n"
  },
  {
    "function": {
      "name": "gds.triangleCount.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.triangleCount.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nTriangle counting is a community detection graph algorithm that is used to\ndetermine the number of triangles passing through each node in the graph.\n\n"
  },
  {
    "function": {
      "name": "gds.triangleCount.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.triangleCount.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nTriangle counting is a community detection graph algorithm that is used to\ndetermine the number of triangles passing through each node in the graph.\n\n"
  },
  {
    "function": {
      "name": "gds.triangleCount.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.triangleCount.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nTriangle counting is a community detection graph algorithm that is used to\ndetermine the number of triangles passing through each node in the graph.\n\n"
  },
  {
    "function": {
      "name": "gds.triangleCount.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nTriangle counting is a community detection graph algorithm that is used to\ndetermine the number of triangles passing through each node in the graph.\n\n"
  },
  {
    "function": {
      "name": "gds.triangles",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nTriangles streams the nodeIds of each triangle in the graph.\n\n"
  },
  {
    "function": {
      "name": "gds.wcc.mutate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe WCC algorithm finds sets of connected nodes in an undirected graph,\nwhere all nodes in the same set form a connected component.\n\n"
  },
  {
    "function": {
      "name": "gds.wcc.mutate.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.wcc.stats",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nExecutes the algorithm and returns result statistics without writing the result to Neo4j.\n\n"
  },
  {
    "function": {
      "name": "gds.wcc.stats.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.wcc.stream",
      "signature": "G: Graph, **config: Any",
      "return_type": "DataFrame"
    },
    "description": "\nThe WCC algorithm finds sets of connected nodes in an undirected graph,\nwhere all nodes in the same set form a connected component.\n\n"
  },
  {
    "function": {
      "name": "gds.wcc.stream.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.wcc.write",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nThe WCC algorithm finds sets of connected nodes in an undirected graph,\nwhere all nodes in the same set form a connected component.\n\n"
  },
  {
    "function": {
      "name": "gds.wcc.write.estimate",
      "signature": "G: Graph, **config: Any",
      "return_type": "Series[Any]"
    },
    "description": "\nReturns an estimation of the memory consumption for that procedure.\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.linkprediction.adamicAdar",
      "signature": "node1: int, node2: int, **config: Any",
      "return_type": "float"
    },
    "description": "\nGiven two nodes, calculate Adamic Adar similarity\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.linkprediction.commonNeighbors",
      "signature": "node1: int, node2: int, **config: Any",
      "return_type": "float"
    },
    "description": "\nGiven two nodes, returns the number of common neighbors\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.linkprediction.preferentialAttachment",
      "signature": "node1: int, node2: int, **config: Any",
      "return_type": "float"
    },
    "description": "\nGiven two nodes, calculate Preferential Attachment\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.linkprediction.resourceAllocation",
      "signature": "node1: int, node2: int, **config: Any",
      "return_type": "float"
    },
    "description": "\nGiven two nodes, calculate Resource Allocation similarity\n\n"
  },
  {
    "function": {
      "name": "gds.alpha.linkprediction.sameCommunity",
      "signature": "node1: int, node2: int, communityProperty: Optional[str] = None",
      "return_type": "float"
    },
    "description": "\nGiven two nodes, indicates if they have the same community\n\n"
  }
]