= GDS Sessions

A GDS Session is a temporary compute environment for running GDS workloads.
It is a service offered by Neo4j and runs within Neo4j's Aura cloud platform.
A GDS Session reads data from a Neo4j DBMS system through a _remote projection_, then runs computations on the projected graph, and lastly can write back the analytical results using _remote write-back_.

NOTE: GDS Sessions are only available for Neo4j AuraDB Enterprise, and not by default. Contact your account manager to get the features enabled.


== GDS Session management

The `GdsSessions` object is the top-level API which allows you three operations:

- `get_or_create`: Create a new GDS Session, or connect to an existing one.
- `list`: List all currently active GDS Sessions.
- `delete`: Delete a GDS Session.


=== Pre-requisites

To create a GDS Session, you need to have a Neo4j Aura account.
Using your account, you need to create Aura API credentials.
These credentials are a pair of `CLIENT_ID` and `CLIENT_SECRET` that you will use to authenticate with the Aura API.
For how to create these credentials, see the https://neo4j.com/docs/aura/platform/api/authentication/#_creating_credentials[Aura documentation].

Using these credentials, you will create a `GdsSessions` object, and use it to create a new GDS Session.

.Creating a GdsSessions object:
[source, python, role=no-test]
----
from graphdatascience.session import GdsSessions, AuraAPICredentials

CLIENT_ID = "my-aura-api-client-id"
CLIENT_SECRET = "my-aura-api-client-secret"

# Create a new GdsSessions object
sessions = GdsSessions(ds_connection=AuraAPICredentials(CLIENT_ID, CLIENT_SECRET))
----


=== Creating a GDS Session

To create a GDS Session, you need to provide the following information:

- **Session name**.
The name must be unique.

- **Session size**.
The size determines the amount of memory and CPU available to the session.
It also determines the cost of running the session.
Available sizes are listed in xref:gds-session-sizes[].

- **DBMS connection**.
This is a `DbmsConnectionInfo` object that contains the URI of an AuraDB instance, a username, and a password.

With these pieces of information, we are ready to create a GDS Session.

.Creating a GDS Session:
[source, python, role=no-test]
----
from graphdatascience.session import SessionSizes, DbmsConnectionInfo

name = "my-new-session"
size = SessionSizes.by_memory().DEFAULT
db_connection_info = DbmsConnectionInfo("neo4j+s://mydbid.databases.neo4j.io", "my-user", "my-password")

gds = sessions.get_or_create(
    session_name=name,
    size=size,
    db_connection=db_connection_info,
)
----

The `get_or_create` method will create a new GDS Session if it does not exist, or connect to an existing one if it does.
If the session size is different from the existing one, an error will be raised.

The return value of `get_or_create` is an `AuraGraphDataScience` object.
It offers a similar API to the `GraphDataScience` object, but it is configured to run on a GDS Session.
By convention, always use the variable name `gds` for the return value of `get_or_create`.


[[gds-session-sizes]]
==== Session sizes

Session sizes are logical and specified using the `SessionSizes.by_memory()` enum.
Possible values are `DEFAULT`, `XS`, `S`, `SM`, `M`, `ML`, `L`, `XL`, `XXL`, `X3L`, `X4L`, `X5L`.


=== Listing GDS Sessions

To list all currently active GDS Sessions, use the `list` method.
This will return the name and size of all currently active sessions.

.Listing GDS Sessions:
[source, python, role=no-test]
----
sessions.list()
----


=== Deleting a GDS Session

To delete a GDS Session, use the `delete` method.
This will terminate the session and stop any running costs from accumulating further.
Deleting a session will not affect the configured AuraDB data source.
However, any data not written back to the AuraDB instance will be lost.

.Deleting a GDS Session:
[source, python, role=no-test]
----
sessions.delete("my-session-name")
----


== Projecting graphs into a GDS Session

Once you have a GDS Session, you can project a graph into it.
We call this a _remote projection_.
It is remote because the data source is not a co-located database, but rather a remote one.

A remote projection is done by using the `gds.graph.project` endpoint.
You will need to provide a graph name, a Cypher query, and additional optional parameters.
The Cypher query must contain the `gds.graph.project.remote` function, which will project the graph into the GDS Session.

=== Syntax

.Remote projection:
[source, role=no-test]
----
gds.graph.project(
    graph_name: str,
    query: str,
    nodePropertySchema: dict[str, GdsPropertyTypes],
    relationshipPropertySchema: dict[str, GdsPropertyTypes],
    undirectedRelationshipTypes: list[str],
    inverseIndexedRelationshipTypes: list[str],
): (Graph, Series[Any])
----

.Parameters:
[opts="header",cols="3m,1,6", role="no-break"]
|===
| Name                            | Optional | Description
| graph_name                      | no       | Name of the graph.
| query                           | no       | Projection query.
| nodePropertySchema              | yes      | Mapping of node property names to their types.
| relationshipPropertySchema      | yes      | Mapping of relationship property names to their types.
| undirectedRelationshipTypes     | yes      | List of relationship type names that should be treated as undirected.
| inverseIndexedRelationshipTypes | yes      | List of relationship type names that should be indexed in reverse.
|===

.Results:
[opts="header",cols="1m,1m,4", role="no-break"]
|===
| Name   | Type        | Description
| graph  | Graph       | Graph object representing the projected graph.
| result | Series[Any] | Statistical data about the projection.
|===


==== Remote projection query syntax

The remote projection query supports the same syntax as a Cypher projection, with two key differences:

. The graph name is not a parameter.
Instead, the graph name is provided to the `gds.graph.project` endpoint.
. The `gds.graph.project.remote` function must be used, instead of the `gds.graph.project` function.

For full details and examples on how to write Cypher projection queries, see the https://neo4j.com/docs/graph-data-science/current/management-ops/graph-creation/graph-project-cypher-projection/[Cypher projection documentation in the GDS Manual].


==== Property schemas

The optional parameters `nodePropertySchema` and `relationshipPropertySchema` are useful when projecting graphs with multiple node labels or relationship types which have distinct property sets.
We call such graphs _heterogeneous graphs_.
If these parameters are not provided, the type of each property will be inferred from the first row of data seen by the projection function.
For homogeneous graphs, this is usually sufficient, but for heterogeneous graphs, it becomes cumbersome to provide default values for each property on every row of data.
We recommend to use the property schema parameters always.


==== Relationship type undirectedness and inverse indexing

The optional parameters `undirectedRelationshipTypes` and `inverseIndexedRelationshipTypes` are used to configure undirectedness and inverse indexing of relationships.
These have the same behaviour as is documented in the https://neo4j.com/docs/graph-data-science/current/management-ops/graph-creation/graph-project-cypher-projection/#graph-project-cypher-projection-syntax[GDS Manual].


=== Example

In this example, we will illustrate how to project a graph into a GDS Session.
The example graph is heterogeneous and models users and products.
Users can know each other, and users can buy products.
We assume here that the database connection is to a new, empty AuraDB instance.

.First, we create a GDS Session and add some data to our database.
[source,python,role=no-test]
----
from graphdatascience.session import SessionSizes, DbmsConnectionInfo, GdsSessions, AuraAPICredentials

sessions = GdsSessions(ds_connection=AuraAPICredentials("my-aura-api-client-id", "my-aura-api-client-secret"))

gds = sessions.get_or_create(
    session_name="my-new-session",
    size=SessionSizes.by_memory().DEFAULT,
    db_connection=DbmsConnectionInfo("neo4j+s://mydbid.databases.neo4j.io", "my-user", "my-password"),
)

gds.run_cypher(
    """
    CREATE
     (u1:User {name: 'Mats'}),
     (u2:User {name: 'Florentin'}),
     (p1:Product {name: 'ice cream', cost: 4.2}),
     (p2:Product {name: 'computer', cost: 13.37})

    CREATE
     (u1)-[:KNOWS {since: 2020}]->(u2),
     (u2)-[:BOUGHT {price: 7474}]->(p1)
    """
)
----

Next, we project the graph into the GDS Session.
There are some node and relationship properties, which we specify using the `nodePropertySchema` and `relationshipPropertySchema` parameters.

[source,python,role=no-test]
----
from graphdatascience.session import GdsPropertyTypes

G, result = gds.graph.project(
    "my-graph",
    """
    CALL {
        MATCH (u1:User)
        OPTIONAL MATCH (u1)-[r:KNOWS]->(u2:User)
        RETURN u1 AS source, r AS rel, u2 AS target, {} AS sourceNodeProperties, {} AS targetNodeProperties
        UNION
        MATCH (p:Product)
        OPTIONAL MATCH (p)<-[r:BOUGHT]-(user:User)
        RETURN user AS source, r AS rel, p AS target, {} AS sourceNodeProperties, {cost: p.cost} AS targetNodeProperties
    }
    RETURN gds.graph.project.remote(source, target, {
      sourceNodeProperties: sourceNodeProperties,
      targetNodeProperties: targetNodeProperties,
      sourceNodeLabels: labels(source),
      targetNodeLabels: labels(target),
      relationshipType: type(rel),
      relationshipProperties: properties(rel)
    })
    """,
    nodePropertySchema={"cost": GdsPropertyTypes.DOUBLE},
    relationshipPropertySchema={"since": GdsPropertyTypes.LONG, "price": GdsPropertyTypes.DOUBLE},
)
----

We have now successfully projected a graph from the AuraDB instance to the new GDS Session and are ready to run algorithms.

== Running algorithms

You can run algorithms on a remotely projected graph in the same way as you would on any other graph.
For a full list of available algorithms, see the https://neo4j.com/docs/graph-data-science-client/{page-version}/api/[API reference].

=== Example 

Extending the previous example, we will now run the PageRank and FastRP algorithms on the projected graph.
Then we will stream the results back joined with the `name` property fetched from the db.

[source,python,role=no-test]
----
gds.pageRank.mutate(G, mutateProperty="pr")
gds.fastRP.mutate(G, featureProperties=["pr"], embeddingDimension=42, mutateProperty="embedding")

gds.graph.nodeProperties.stream(G, db_properties=["name"], node_properties=["pr", "embedding"])
----


== Remote write-back

The GDS Session's in-memory graph was projected from data in AuraDB.
Write back operations will thus persist the data back to the same AuraDB.
When calling any write operations the GDS Python client will automatically use the remote write back functionality.
This includes all `.write` algorithm modes as well as all `.write` graph operations.

=== Example

Extending the previous example, we will now write back the FastRP embeddings to the AuraDB instance.

[source,python,role=no-test]
----
gds.graph.nodeProperty.write(G, "embedding")
----


== Querying the database

You can run Cypher queries on the AuraDB instance using the `run_cypher` method.
There is no restriction on the type of query that can be run, but it is important to note that the query will be run on the AuraDB instance, and not on the GDS Session.
Thus you will not be able to call gds operations from the `run_cypher` method.


[source,python,role=no-test]
----
gds.run_cypher("MATCH (n:User) RETURN n.name, n.embedding")
----

We have now integrated our analytical results with the original data in the AuraDB instance.


